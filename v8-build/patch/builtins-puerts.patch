diff --git a/.gitignore b/.gitignore
index ffbf9ce355..c408c7d7c7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -104,3 +104,5 @@ turbo*.dot
 turbo*.json
 v8.ignition_dispatches_table.json
 
+build.sh
+puerts
\ No newline at end of file
diff --git a/include/v8.h b/include/v8.h
index 18d72f1630..5aa1888978 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -38,6 +38,9 @@
  */
 namespace v8 {
 
+namespace Puerts {
+  class FunctionCallbackInfo;
+}
 class AccessorSignature;
 class Array;
 class ArrayBuffer;
@@ -307,6 +310,7 @@ class Local {
   template <class F>
   friend class MaybeLocal;
   template<class F> friend class FunctionCallbackInfo;
+  friend class Puerts::FunctionCallbackInfo;
   template<class F> friend class PropertyCallbackInfo;
   friend class String;
   friend class Object;
@@ -12038,6 +12042,104 @@ size_t SnapshotCreator::AddData(Local<T> object) {
  */
 
 
+namespace Puerts {
+
+  enum JsValueType {
+      NullOrUndefined = 1,
+      BigInt          = 2,
+      Number          = 4,
+      String          = 8,
+      Boolean         = 16,
+      NativeObject    = 32,
+      JsObject        = 64,
+      Array           = 128,
+      Function        = 256,
+      Date            = 512,
+      ArrayBuffer     = 1024,
+      Unknow          = 2048,
+  };
+
+  #pragma pack(8)
+  union ValueUnion {
+      double Number;
+      bool Boolean;
+      int64_t BigInt;
+      void* Pointer;
+  };
+
+  struct CSharpToJsValue {
+      JsValueType Type;
+      int classIDOrValueLength;
+      ValueUnion Data;
+  };
+  #pragma pack()
+
+  struct FunctionInfo;
+
+  typedef void (*CallbackFunction)(v8::Isolate* Isolate, CSharpToJsValue* value, const v8::Puerts::FunctionCallbackInfo& Info, void* Self, int ParamLen, int64_t Data);
+
+  typedef v8::Local<v8::Value> (*CallbackWrap)(v8::Isolate* Isolate, const v8::Puerts::FunctionCallbackInfo& Info, void* Self, int ParamLen, FunctionInfo* functionInfo);
+
+  struct FunctionInfo { 
+    bool isStatic;
+    CallbackFunction callback;
+    CallbackWrap wrap;
+    void* bindData;
+  };
+  class FunctionCallbackInfo {
+    class ReturnValue {
+      protected:
+        internal::Address* value_;
+        bool* is_return_value_setted_;
+      public:
+        ReturnValue(internal::Address* slot, bool* isReturnValueSetted) 
+          : value_(slot), is_return_value_setted_(isReturnValueSetted) {}
+        internal::Address* Get() 
+        {
+          return value_;
+        }
+        void Set(const Local<Value> handle);
+    };
+    private:
+      internal::Address* return_value_;
+      bool* is_return_value_setted_;
+      internal::Address* values_;
+      int length_;
+    public:
+      FunctionCallbackInfo(
+        internal::Address* address, 
+        internal::Address* returnValue, 
+        bool* isReturnValueSetted,
+        int length
+      ) {
+        this->values_ = address;
+        this->length_ = length;
+        return_value_ = returnValue;
+        is_return_value_setted_ = isReturnValueSetted;
+      }
+      FunctionCallbackInfo(
+        v8::Local<v8::Value> address, 
+        int length
+      ) {
+        this->values_ = reinterpret_cast<internal::Address*>(*address);
+        this->length_ = length;
+      }
+      ReturnValue GetReturnValue() const {
+        return ReturnValue(return_value_, is_return_value_setted_);
+      }
+      int Length() const {
+        return length_;
+      }
+      Local<Value> operator[](int i) const {
+      #ifdef V8_REVERSE_JSARGS
+        return Local<Value>(reinterpret_cast<Value*>(values_ + i));
+      #else
+        return Local<Value>(reinterpret_cast<Value*>(values_ - i));
+      #endif
+      }
+  };
+}
+
 }  // namespace v8
 
 #endif  // INCLUDE_V8_H_
diff --git a/src/api/api.cc b/src/api/api.cc
index 93780bceec..0b600916ad 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -11181,6 +11181,12 @@ void InvokeFinalizationRegistryCleanupFromTask(
 #undef CALLBACK_SETTER
 
 }  // namespace internal
+
+void Puerts::FunctionCallbackInfo::ReturnValue::Set(const v8::Local<v8::Value> handle) {
+  *is_return_value_setted_ = true;
+  *value_ = *reinterpret_cast<internal::Address*>(*handle);
+}
+
 }  // namespace v8
 
 #undef TRACE_BS
diff --git a/src/builtins/builtins-api.cc b/src/builtins/builtins-api.cc
index 6eb6f87c74..40d455792b 100644
--- a/src/builtins/builtins-api.cc
+++ b/src/builtins/builtins-api.cc
@@ -12,6 +12,7 @@
 #include "src/objects/prototype.h"
 #include "src/objects/templates.h"
 #include "src/objects/visitors.h"
+#include "src/init/bootstrapper.h"
 
 namespace v8 {
 namespace internal {
@@ -309,5 +310,172 @@ BUILTIN(HandleApiCallAsConstructor) {
   return HandleApiCallAsFunctionOrConstructor(isolate, true, args);
 }
 
+internal::Handle<Object> MakeHandle(
+  internal::Isolate* isolate,
+  v8::Puerts::CSharpToJsValue* value
+) {
+  switch (value->Type) {
+    case Puerts::JsValueType::NullOrUndefined:
+      return isolate->factory()->undefined_value();
+    case Puerts::JsValueType::Number:
+      return isolate->factory()->NewNumber(value->Data.Number);
+    case Puerts::JsValueType::String:
+      return isolate->factory()->NewStringFromAsciiChecked((const char *)value->Data.Pointer);
+    case Puerts::JsValueType::Boolean:
+      return isolate->factory()->ToBoolean(value->Data.Boolean);
+    default:
+      return isolate->factory()->undefined_value();
+  }
+}
+
+V8_WARN_UNUSED_RESULT MaybeHandle<Object> PuertsCallDRHandler(
+  internal::Isolate* isolate, 
+  Handle<JSObject> puertsThis,
+  BuiltinArguments&  args
+) {
+  Puerts::FunctionInfo* functionInfo = (v8::Puerts::FunctionInfo*)Foreign::cast(
+    JSObject::cast(puertsThis->GetEmbedderField(0)).GetEmbedderField(0)
+  ).foreign_address();
+  
+  int argLength = args.length() - 2;
+  internal::Address returnValue = 0;
+  bool isReturnValueSetted = false;
+  Puerts::FunctionCallbackInfo callbackInfo(
+    args.address_of_arg_at(2), 
+    &returnValue,
+    &isReturnValueSetted,
+    argLength
+  );
+  
+  v8::Local<v8::Value> value = functionInfo->wrap(
+    reinterpret_cast<v8::Isolate*>(isolate),
+    callbackInfo,
+    functionInfo->isStatic ? nullptr : reinterpret_cast<void*>(
+      internal::Internals::ReadExternalPointerField(
+        isolate,
+        args.at(1)->ptr(),
+        internal::Internals::kJSObjectHeaderSize
+      )
+    ),
+    argLength,
+    functionInfo
+  );
+
+  RETURN_EXCEPTION_IF_SCHEDULED_EXCEPTION(isolate, Object);
+
+  return Utils::OpenHandle(*value);
+}
+V8_WARN_UNUSED_RESULT MaybeHandle<Object> PuertsCallDRHandler2(
+  internal::Isolate* isolate, 
+  internal::JSObject puertsThis,
+  BuiltinArguments&  args
+) {
+  Puerts::FunctionInfo* functionInfo = (v8::Puerts::FunctionInfo*)Foreign::cast(
+    JSObject::cast(puertsThis.GetEmbedderField(0)).GetEmbedderField(0)
+  ).foreign_address();
+  
+  int argLength = args.length() - 1;
+  internal::Address returnValue = 0;
+  bool isReturnValueSetted = false;
+  Puerts::FunctionCallbackInfo callbackInfo(
+    args.address_of_arg_at(1), 
+    &returnValue,
+    &isReturnValueSetted,
+    argLength
+  );
+  
+  v8::Local<v8::Value> value = functionInfo->wrap(
+    reinterpret_cast<v8::Isolate*>(isolate),
+    callbackInfo,
+    functionInfo->isStatic ? nullptr : reinterpret_cast<void*>(
+      internal::Internals::ReadExternalPointerField(
+        isolate,
+        args.at(0)->ptr(),
+        internal::Internals::kJSObjectHeaderSize
+      )
+    ),
+    argLength,
+    functionInfo
+  );
+
+  RETURN_EXCEPTION_IF_SCHEDULED_EXCEPTION(isolate, Object);
+
+  return Utils::OpenHandle(*value);
+}
+V8_WARN_UNUSED_RESULT MaybeHandle<Object> PuertsCallHandler(
+  internal::Isolate* isolate, 
+  Handle<JSObject> puertsThis,
+  BuiltinArguments&  args
+) {
+  Puerts::FunctionInfo* functionInfo = (Puerts::FunctionInfo*)Foreign::cast(
+    JSObject::cast(puertsThis->GetEmbedderField(0)).GetEmbedderField(0)
+  ).foreign_address();
+  
+  int argLength = args.length() - 2;
+  internal::Address returnValue = 0;
+  bool isReturnValueSetted = false;
+  Puerts::FunctionCallbackInfo callbackInfo(
+    args.address_of_arg_at(2), 
+    &returnValue,
+    &isReturnValueSetted,
+    argLength
+  );
+  
+  functionInfo->callback(
+    reinterpret_cast<v8::Isolate*>(isolate),
+    nullptr,
+    callbackInfo,
+    functionInfo->isStatic ? nullptr : reinterpret_cast<void*>(
+      internal::Internals::ReadExternalPointerField(
+        isolate,
+        args.at(1)->ptr(),
+        internal::Internals::kJSObjectHeaderSize
+      )
+    ),
+    argLength,
+    (int64_t)functionInfo->bindData
+  );
+  RETURN_EXCEPTION_IF_SCHEDULED_EXCEPTION(isolate, Object);
+
+  if (isReturnValueSetted) {
+    return MaybeHandle<Object>(internal::Object(returnValue), isolate);
+
+  } else {
+    return isolate->factory()->undefined_value();
+  }
+}
+
+BUILTIN(ApiPuertsMakeCallback) {
+  Handle<String> internalized_name = args.at<String>(1);
+
+  NewFunctionArgs funArgs = NewFunctionArgs::ForBuiltinWithoutPrototype(
+      internalized_name, Builtins::kApiPuertsDRCallback2, LanguageMode::kStrict);
+  Handle<JSFunction> fun = isolate->factory()->NewFunction(funArgs);
+  fun->shared().set_native(true);
+  fun->shared().DontAdaptArguments();
+  fun->shared().set_function_data(*args.at(2), WriteBarrierMode::UPDATE_WRITE_BARRIER);
+
+  return *fun;
+}
+BUILTIN(ApiPuertsDRCallback2) {
+  Handle<JSFunction> callbackFun = args.target();
+  RETURN_RESULT_OR_FAILURE(
+    isolate, 
+    PuertsCallDRHandler2(
+      isolate, 
+      JSObject::cast(callbackFun->shared().function_data()),
+      args
+    )
+  );
+  // return callbackFun->shared().function_data();
+}
+BUILTIN(ApiPuertsDRCallback) {
+  Handle<JSObject> puertsThis = args.at<JSObject>(0);
+  RETURN_RESULT_OR_FAILURE(isolate, PuertsCallDRHandler(isolate, puertsThis, args));
+}
+BUILTIN(ApiPuertsCallback) {
+  Handle<JSObject> puertsThis = args.at<JSObject>(0);
+  RETURN_RESULT_OR_FAILURE(isolate, PuertsCallHandler(isolate, puertsThis, args));
+}
 }  // namespace internal
 }  // namespace v8
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 84ddf55f6f..553a8624f1 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -792,6 +792,10 @@ namespace internal {
   TFJ(StringPrototypeTrimStart, kDontAdaptArgumentsSentinel)                   \
   /* ES6 #sec-string.raw */                                                    \
   CPP(StringRaw)                                                               \
+  CPP(ApiPuertsCallback)                                                       \
+  CPP(ApiPuertsDRCallback)                                                     \
+  CPP(ApiPuertsDRCallback2)                                                     \
+  CPP(ApiPuertsMakeCallback)                                                   \
                                                                                \
   /* Symbol */                                                                 \
   /* ES #sec-symbol-constructor */                                             \
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index f4049e328e..ce63e6914c 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -1917,6 +1917,16 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     SimpleInstallFunction(isolate_, string_fun, "raw", Builtins::kStringRaw, 1,
                           false);
 
+    // === zombie ===
+
+    Handle<JSObject> puerts_object =
+        factory->NewJSObject(isolate_->object_function(), AllocationType::kOld);
+    JSObject::AddProperty(isolate_, global, "PuertsV8", puerts_object, DONT_ENUM);
+
+    SimpleInstallFunction(isolate_, puerts_object, "callback", Builtins::kApiPuertsCallback, 1, false);
+    SimpleInstallFunction(isolate_, puerts_object, "drCallback", Builtins::kApiPuertsDRCallback, 1, false);
+    SimpleInstallFunction(isolate_, puerts_object, "makeCallback", Builtins::kApiPuertsMakeCallback, 2, false);
+
     // Create the %StringPrototype%
     Handle<JSPrimitiveWrapper> prototype = Handle<JSPrimitiveWrapper>::cast(
         factory->NewJSObject(string_fun, AllocationType::kOld));
